#!/usr/bin/env bash
# NewsoftDS API Gateway Buildpack for Heroku
# Forces Bun 1.2.23 for compatibility
#
set -e

# üé® Pretty logging functions
log_header() { echo ""; echo "üöÄ $1"; echo ""; }
log_step() { echo "   üì¶ $1"; }
log_success() { echo "   ‚úÖ $1"; }
log_info() { echo "   ‚ÑπÔ∏è  $1"; }
log_error() { echo "   ‚ùå $1"; }

# üìÇ Directory setup
BUILD_DIR=${1:-.}
CACHE_DIR=${2:-}
ENV_DIR=${3:-}

log_header "NewsoftDS API Gateway Buildpack v1.0 (Bun 1.2.23)"

# üîß Export environment variables from Heroku
export_env_dir() {
  if [ -d "$1" ]; then
    for e in $(ls $1); do
      case $e in
        PATH|GIT_DIR|CPATH|CPPATH|LD_PRELOAD|LIBRARY_PATH) ;;
        *) export "$e=$(cat $1/$e)" ;;
      esac
    done
  fi
}

export_env_dir $ENV_DIR

# ‚öôÔ∏è Configuration with defaults
BP_NODE=${BP_NODE:-"true"}
BP_NODE_VERSION=${BP_NODE_VERSION:-"22.11.0"}
BP_INSTALL=${BP_INSTALL:-"bun install"}
BP_CLEAN=${BP_CLEAN:-"true"}

# FORCE BUN VERSION 1.2.23
FORCED_BUN_VERSION="1.2.23"
log_info "FORCING Bun version: $FORCED_BUN_VERSION (required for API Gateway compatibility)"

# Helper function to check boolean values
is_true() {
  case "$1" in
    true|TRUE|True|1|yes|YES|Yes|on|ON|On) return 0 ;;
    *) return 1 ;;
  esac
}

# ‚ùó Validate required environment variables
VALIDATION_FAILED=false

if [ -z "$BP_BUILD" ]; then
  log_error "BP_BUILD environment variable is required!"
  log_info "Set it with: heroku config:set BP_BUILD=@newsoftds/api-gateway-server"
  log_info "Or: heroku config:set BP_BUILD=apis/servers/api-gateway-server"
  VALIDATION_FAILED=true
fi

if [ -z "$BP_START_COMMAND" ]; then
  log_error "BP_START_COMMAND environment variable is required!"
  log_info "Set it with: heroku config:set BP_START_COMMAND='bun run start'"
  VALIDATION_FAILED=true
fi

if [ "$VALIDATION_FAILED" = true ]; then
  log_header "‚ùå Build Failed - Missing Required Environment Variables"
  log_info "Please set the required variables and redeploy:"
  log_info "heroku config:set BP_BUILD=@newsoftds/api-gateway-server"
  log_info "heroku config:set BP_START_COMMAND='bun run start'"
  exit 1
fi

log_info "Project to build: $BP_BUILD"
log_info "Start command: $BP_START_COMMAND"
if is_true "$BP_NODE"; then
  log_info "Node.js: enabled (v$BP_NODE_VERSION)"
else
  log_info "Node.js: disabled (Bun only)"
fi

# üèóÔ∏è Setup build environment
HEROKU_DIR=$BUILD_DIR/.heroku
mkdir -p $HEROKU_DIR/bin

# Move to build directory
cd $BUILD_DIR

# üì¶ Install Node.js (optional)
if is_true "$BP_NODE"; then
  log_step "Installing Node.js v$BP_NODE_VERSION"
  NODE_DISTRO="node-v$BP_NODE_VERSION-linux-x64"
  NODE_TAR="$NODE_DISTRO.tar.xz"
  NODE_URL="https://nodejs.org/dist/v$BP_NODE_VERSION/$NODE_TAR"

  curl -O $NODE_URL
  tar -xf $NODE_TAR || {
    log_error "Error extracting Node.js tarball"
    exit 1
  }
  mkdir -p $HEROKU_DIR/node
  mv $NODE_DISTRO/* $HEROKU_DIR/node
  rm -rf $NODE_TAR $NODE_DISTRO

  export PATH="$HEROKU_DIR/node/bin:$PATH"
  log_success "Node.js installed: $(node --version)"
else
  log_step "Skipping Node.js installation (BP_NODE=false)"
fi

# ü•Ø Install Bun 1.2.23 (FORCED)
log_step "Installing Bun $FORCED_BUN_VERSION (FORCED VERSION)"

# Clean up any previous Bun installations to avoid bloat
rm -rf $BUILD_DIR/.heroku/cache $BUILD_DIR/.heroku/.cache $BUILD_DIR/.heroku/install
log_info "Cleaned previous Bun cache"

export BUN_INSTALL=$BUILD_DIR/.heroku
# Explicitly set BUN_DIR to a temp location that we'll clean
export BUN_DIR=/tmp/bun-cache-$$

# The Bun install script expects format: bun-vX.Y.Z (with 'v' prefix)
BUN_INSTALL_TAG="bun-v$FORCED_BUN_VERSION"
log_info "Downloading Bun from tag: $BUN_INSTALL_TAG"
curl -fsSL https://bun.sh/install | bash -s "$BUN_INSTALL_TAG"

export PATH="$BUN_INSTALL/bin:$PATH"
log_success "Bun installed: $(bun --version)"

# Verify we got the correct version
INSTALLED_VERSION=$(bun --version)
if [ "$INSTALLED_VERSION" != "$FORCED_BUN_VERSION" ]; then
  log_error "Bun version mismatch! Expected $FORCED_BUN_VERSION but got $INSTALLED_VERSION"
  exit 1
fi
log_success "Verified Bun version: $FORCED_BUN_VERSION ‚úÖ"

# Clean up Bun temp cache immediately
rm -rf /tmp/bun-cache-*
log_info "Bun installation size: $(du -sh $BUILD_DIR/.heroku | cut -f1)"

# üìã Setup runtime environment
PROFILE_PATH="$BUILD_DIR/.profile.d/bun.sh"
mkdir -p $(dirname $PROFILE_PATH)
if is_true "$BP_NODE"; then
  cat > $PROFILE_PATH << 'EOF'
export PATH="$HOME/.heroku/node/bin:$PATH"
export PATH="$HOME/.heroku/bin:$PATH"
EOF
else
  cat > $PROFILE_PATH << 'EOF'
export PATH="$HOME/.heroku/bin:$PATH"
EOF
fi

# üì¶ Install monorepo dependencies
log_step "Installing monorepo dependencies"

# Handle BP_APP_DIR if set (for compatibility with old buildpack)
if [ -n "$BP_APP_DIR" ]; then
  log_info "BP_APP_DIR is set: $BP_APP_DIR"
  if [ -d "$BP_APP_DIR" ]; then
    cd "$BP_APP_DIR"
    log_info "Changed to directory: $BP_APP_DIR"
  else
    log_error "BP_APP_DIR directory not found: $BP_APP_DIR"
    exit 1
  fi
fi

log_info "Running: $BP_INSTALL --ignore-scripts"

# Add --ignore-scripts to prevent postinstall database connections
if [[ "$BP_INSTALL" == *"--ignore-scripts"* ]]; then
  eval $BP_INSTALL
else
  eval "$BP_INSTALL --ignore-scripts"
fi

if [ $? -eq 0 ]; then
  log_success "Dependencies installed"
else
  log_error "Dependency installation failed"
  exit 1
fi

# Return to build directory
cd $BUILD_DIR

# üèóÔ∏è Build the project
log_step "Building $BP_BUILD"

# Determine project path
PROJECT_PATH=""
if [[ "$BP_BUILD" == @* ]]; then
  # It's a package name, try to find it
  case $BP_BUILD in
    "@newsoftds/api-gateway-server")
      PROJECT_PATH="apis/servers/api-gateway-server"
      ;;
    "@newsoftds/api-clinic-server")
      PROJECT_PATH="apis/servers/api-clinic-server"
      ;;
    "@newsoftds/api-university-server")
      PROJECT_PATH="apis/servers/api-university-server"
      ;;
    *)
      # Try to auto-detect
      for project_file in $(find . -name "package.json" -not -path "./node_modules/*" 2>/dev/null); do
        project_name=$(cat "$project_file" | bun -e 'const p=JSON.parse(await Bun.stdin.text()); console.log(p.name || "")' 2>/dev/null)
        if [ "$project_name" = "$BP_BUILD" ]; then
          PROJECT_PATH=$(dirname "$project_file")
          break
        fi
      done
      ;;
  esac
else
  # It's already a path
  PROJECT_PATH="$BP_BUILD"
fi

if [ -z "$PROJECT_PATH" ] || [ ! -d "$PROJECT_PATH" ]; then
  log_error "Project not found: $BP_BUILD"
  log_info "Check that BP_BUILD is either a valid package name or path"
  exit 1
fi

log_info "Project path: $PROJECT_PATH"
cd "$PROJECT_PATH"

# Check for custom build command
if [ -n "$BP_BUILD_COMMAND" ]; then
  log_info "Running custom build command: $BP_BUILD_COMMAND"
  eval $BP_BUILD_COMMAND
elif [ -f "package.json" ] && grep -q '"build:heroku"' package.json; then
  log_info "Running build:heroku script"
  bun run build:heroku
elif [ -f "package.json" ] && grep -q '"build"' package.json; then
  log_info "Running build script"
  bun run build
else
  log_error "No build script found in package.json"
  log_info "Add a 'build:heroku' or 'build' script to your package.json"
  log_info "Or set BP_BUILD_COMMAND environment variable"
  exit 1
fi

log_success "Build completed"

# üì¶ Check dist directory
DIST_DIR="dist"
if [ -n "$BP_RUNTIME_DIR" ]; then
  DIST_DIR="$BP_RUNTIME_DIR"
  log_info "Using custom runtime directory: $DIST_DIR"
fi

if [ ! -d "$DIST_DIR" ]; then
  log_error "Build did not create a $DIST_DIR directory"
  exit 1
fi

# Move dist contents to app root
log_step "Preparing deployment"

# Handle BP_START_IN_RUNTIME flag
if [ "$BP_START_IN_RUNTIME" = "true" ]; then
  log_info "BP_START_IN_RUNTIME is true - copying runtime dir to root"
  cp -r $DIST_DIR/* $BUILD_DIR/
else
  log_info "Copying build output from $DIST_DIR to $BUILD_DIR"
  cp -r $DIST_DIR/* $BUILD_DIR/
fi

cd $BUILD_DIR

# üîç Check if we have a package.json in the build output
if [ ! -f "package.json" ]; then
  log_error "No package.json found in build output"
  log_info "Your build script should generate a package.json in dist/"
  exit 1
fi

# üì¶ Install production dependencies
log_step "Installing production dependencies"

# Remove any existing lockfile to ensure fresh install
rm -f bun.lockb bun.lock package-lock.json yarn.lock
log_info "Removed any existing lockfiles"

# Force Bun to not use frozen lockfile (Heroku might set CI=true)
export CI=false
export BUN_INSTALL_FROZEN_LOCKFILE=false

# CRITICAL: Remove old monorepo node_modules FIRST before installing production deps
log_info "Removing old monorepo node_modules..."
if [ -d "node_modules" ]; then
  OLD_SIZE=$(du -sh node_modules | cut -f1)
  log_info "Deleting old node_modules (size: $OLD_SIZE)"
  rm -rf node_modules
fi

# Use bun for production install
log_info "Running: bun install --production --ignore-scripts --no-frozen-lockfile"
bun install --production --ignore-scripts --no-frozen-lockfile || {
  log_error "Installation failed, trying without production flag..."
  bun install --ignore-scripts --no-frozen-lockfile || {
    log_error "Installation failed completely"
    exit 1
  }
}

# Verify new node_modules size
if [ -d "node_modules" ]; then
  NEW_SIZE=$(du -sh node_modules | cut -f1)
  log_info "New production node_modules size: $NEW_SIZE"
fi

log_success "Production dependencies installed"

# üéØ Create Procfile with BP_START_COMMAND
log_step "Creating Procfile"

# Use BP_START_COMMAND directly
START_CMD="$BP_START_COMMAND"
log_info "Using start command: $START_CMD"

# Write the Procfile
echo "web: $START_CMD" > Procfile
log_success "Created Procfile with: web: $START_CMD"

# üßπ Cleanup to reduce slug size
if is_true "$BP_CLEAN"; then
  log_step "Cleaning up to reduce slug size"

  # Show what's taking space before cleanup
  log_info "Largest directories before cleanup:"
  du -sh * 2>/dev/null | sort -rh | head -10 || true

  # Remove source directories (we already copied dist to root)
  rm -rf apis web desktop packages utils tools apps
  log_info "Removed source directories"

  # Keep node_modules for runtime
  log_info "Keeping node_modules for runtime dependencies"

  # Remove caches and build artifacts
  rm -rf .nx .cache tmp .heroku/cache
  rm -rf *.md *.lock *.lockb tsconfig*.json nx.json biome.json
  log_info "Removed build artifacts and caches"

  # Remove git directory
  if [ -d ".git" ]; then
    GIT_SIZE=$(du -sh .git | cut -f1)
    log_info "Removing .git directory (size: $GIT_SIZE)"
    rm -rf .git
  fi

  # Clean .heroku directory
  if [ -d ".heroku" ]; then
    log_info "Contents of .heroku directory:"
    du -sh .heroku/* 2>/dev/null | sort -rh | head -10 || true

    # Remove cache directories but keep bin and node
    rm -rf .heroku/cache .heroku/tmp .heroku/src .heroku/plugins .heroku/.cache

    # Remove the massive install directory but keep bun executable
    if [ -f ".heroku/bin/bun" ] && [ -d ".heroku/install" ]; then
      INSTALL_SIZE=$(du -sh .heroku/install | cut -f1)
      log_info "Removing .heroku/install directory (size: $INSTALL_SIZE)"
      rm -rf .heroku/install
    fi

    # Clean package caches
    find .heroku -type d -name "node_modules" -exec rm -rf {} + 2>/dev/null || true
    find .heroku -type d -name ".cache" -exec rm -rf {} + 2>/dev/null || true
    find .heroku -type d -name "cache" -exec rm -rf {} + 2>/dev/null || true

    log_info "Cleaned .heroku directory (kept bin and node)"

    # Check final .heroku size
    HEROKU_SIZE=$(du -sh .heroku | cut -f1)
    log_info "Final .heroku directory size: $HEROKU_SIZE"
  fi

  # Show what's left
  log_info "Remaining files after cleanup:"
  du -sh * 2>/dev/null | sort -rh | head -10 || true

  SLUG_SIZE=$(du -sh . | cut -f1)
  log_success "Cleanup complete - final slug size: $SLUG_SIZE"
else
  log_info "Skipping cleanup (BP_CLEAN not set to true)"
fi

# üîç Verify executables exist
log_step "Verifying runtime executables"
if is_true "$BP_NODE"; then
  if [ -f ".heroku/node/bin/node" ]; then
    log_success "Node executable found: .heroku/node/bin/node"
    if [ -f ".heroku/node/bin/npm" ]; then
      log_success "NPM executable found: .heroku/node/bin/npm"
    elif [ -f ".heroku/node/lib/node_modules/npm/bin/npm-cli.js" ]; then
      ln -sf "../lib/node_modules/npm/bin/npm-cli.js" ".heroku/node/bin/npm"
      log_success "Created NPM symlink"
    else
      log_error "NPM executable NOT found!"
    fi

    if [ ! -f ".heroku/node/bin/npx" ] && [ -f ".heroku/node/lib/node_modules/npm/bin/npx-cli.js" ]; then
      ln -sf "../lib/node_modules/npm/bin/npx-cli.js" ".heroku/node/bin/npx"
      log_success "Created NPX symlink"
    fi
  else
    log_error "Node executable NOT found!"
  fi
fi

if [ -f ".heroku/bin/bun" ]; then
  log_success "Bun executable found: .heroku/bin/bun"
  # Verify version again
  FINAL_VERSION=$(.heroku/bin/bun --version)
  if [ "$FINAL_VERSION" != "$FORCED_BUN_VERSION" ]; then
    log_error "Bun version verification failed! Expected $FORCED_BUN_VERSION but found $FINAL_VERSION"
    exit 1
  fi
  log_success "Bun version verified: $FINAL_VERSION ‚úÖ"
else
  log_error "Bun executable NOT found!"
fi

# üìä Final summary
log_header "Build Summary"
log_success "Project: $BP_BUILD"
log_success "Built from: $PROJECT_PATH"
log_success "Start command: $BP_START_COMMAND"
log_success "Slug size: $(du -sh . | cut -f1)"
if is_true "$BP_NODE"; then
  log_success "Runtime: Bun $FORCED_BUN_VERSION (FORCED) + Node $(node --version)"
else
  log_success "Runtime: Bun $FORCED_BUN_VERSION (FORCED)"
fi

log_info "Your app will start with: $BP_START_COMMAND"
log_info "Bun version is LOCKED to $FORCED_BUN_VERSION for compatibility"

log_header "‚úÖ Build Complete - Ready for deployment!"
